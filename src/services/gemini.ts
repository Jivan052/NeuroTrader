// Gemini API service
import { SentimentData } from './santiment';
import { CoinGeckoMarketData } from './coingecko';

// Define types for AI insights
export type AIInsightRequest = {
  token: string;
  marketData: {
    price: number;
    priceChange24h: number;
    priceChangePercentage24h: number;
    volume24h: number;
    marketCap: number;
    high24h: number;
    low24h: number;
    supply: number;
    maxSupply: number | null;
  };
  sentimentData: {
    overall: number;
    social: number;
    news: number;
  };
  timeframe: string;
};

export type AIInsightResponse = {
  conclusion: string;
  bullishFactors: string[];
  bearishFactors: string[];
  recommendation: string;
  confidence: number;
};

/**
 * Generate AI insights using Gemini API
 * @param marketData Market data from CoinGecko
 * @param sentimentData Sentiment data from Santiment
 * @param token Token symbol
 * @returns Promise with AI-generated insights
 */
// Create a cache for AI insights to avoid excessive API calls
const aiInsightsCache: Record<string, { data: AIInsightResponse, timestamp: number }> = {};

// Cache timeout - 30 minutes
const CACHE_TIMEOUT = 30 * 60 * 1000;

export const generateAIInsights = async (
  marketData: CoinGeckoMarketData,
  sentimentData: SentimentData,
  token: string
): Promise<AIInsightResponse> => {
  // Check if we have a recent cached response
  const cacheKey = `${token}-${marketData.current_price}-${sentimentData.overall}`;
  const cachedResult = aiInsightsCache[cacheKey];
  
  if (cachedResult && (Date.now() - cachedResult.timestamp) < CACHE_TIMEOUT) {
    console.log(`Using cached AI insights for ${token}`);
    return cachedResult.data;
  }
  
  const geminiApiKey = import.meta.env.VITE_GEMINI_API_KEY;
  
  if (!geminiApiKey) {
    console.error('Gemini API key not configured. Using fallback analysis.');
    return getFallbackAnalysis(token, marketData, sentimentData);
  }
  
  // Include positive and negative topics in the prompt for better context
  const positiveTopics = sentimentData.positiveTopics.join(', ');
  const negativeTopics = sentimentData.negativeTopics.join(', ');
  
  const prompt = `
    You are NeuroTrader, an expert cryptocurrency analyst AI. 
    
    Analyze the following real-time data for ${token} and provide trading insights:
    
    Market Data:
    - Current Price: $${marketData.current_price}
    - 24h Price Change: ${marketData.price_change_percentage_24h.toFixed(2)}%
    - 24h Volume: $${marketData.total_volume}
    - Market Cap: $${marketData.market_cap}
    - 24h High: $${marketData.high_24h}
    - 24h Low: $${marketData.low_24h}
    - Circulating Supply: ${marketData.circulating_supply} ${token}
    - Maximum Supply: ${marketData.max_supply || 'Unlimited'}
    
    Sentiment Analysis:
    - Overall Sentiment Score: ${sentimentData.overall.toFixed(2)} (-100 to 100 scale)
    - Social Media Sentiment: ${sentimentData.social.toFixed(2)}
    - News Sentiment: ${sentimentData.news.toFixed(2)}
    - Positive Topics: ${positiveTopics}
    - Negative Topics: ${negativeTopics}
    
    Based on this real-time data, provide a JSON response with the following structure:
    {
      "conclusion": "A concise 2-3 sentence analysis of ${token}'s current state",
      "bullishFactors": ["List of 2-4 bullish factors, each as a brief phrase"],
      "bearishFactors": ["List of 1-3 bearish factors or risks, each as a brief phrase"],
      "recommendation": "A clear trading recommendation in 1-2 sentences",
      "confidence": 75 // A number between 0-100 indicating your confidence in this analysis
    }
    
    Make your analysis thoughtful, data-driven, and specific to ${token}'s unique situation.
    Only return the JSON object, no other text.
  `;
  
  try {
    const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiApiKey}`;
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { text: prompt }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.2,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        }
      })
    });
    
    if (!response.ok) {
      console.warn(`Gemini API error: ${response.status} ${response.statusText}`);
      return getFallbackAnalysis(token, marketData, sentimentData);
    }
    
    const result = await response.json();
    const generatedText = result.candidates[0]?.content?.parts[0]?.text;
    
    if (!generatedText) {
      console.warn('No text generated by Gemini API');
      return getFallbackAnalysis(token, marketData, sentimentData);
    }
    
    // Extract the JSON from the response
    const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.warn('Could not extract JSON from Gemini response');
      return getFallbackAnalysis(token, marketData, sentimentData);
    }
    
    try {
      const parsedResult = JSON.parse(jsonMatch[0]);
      
      // Cache the result
      aiInsightsCache[`${token}-${marketData.current_price}-${sentimentData.overall}`] = {
        data: parsedResult,
        timestamp: Date.now()
      };
      
      return parsedResult;
    } catch (parseError) {
      console.warn('Error parsing JSON from Gemini response:', parseError);
      return getFallbackAnalysis(token, marketData, sentimentData);
    }
  } catch (error) {
    console.error('Error generating AI insights:', error);
    return getFallbackAnalysis(token, marketData, sentimentData);
  }
}

/**
 * Generate fallback analysis when Gemini API fails
 */
const getFallbackAnalysis = (
  token: string, 
  marketData: CoinGeckoMarketData, 
  sentimentData: SentimentData
): AIInsightResponse => {
  console.log(`Generating fallback analysis for ${token}`);
  
  let conclusion = "";
  let recommendation = "";
  let bullishFactors: string[] = [];
  let bearishFactors: string[] = [];
  let confidence = 0;
  
  // Generate analysis based on price change and sentiment
  const priceChange = marketData.price_change_percentage_24h;
  const overallSentiment = sentimentData.overall;
  
  if (priceChange > 5 && overallSentiment > 30) {
    // Strong bullish scenario
    conclusion = `${token} is showing strong bullish momentum with significant price appreciation and positive sentiment signals.`;
    recommendation = `Consider increasing ${token} position on minor pullbacks with appropriate risk management.`;
    bullishFactors = [
      `Strong price action (+${priceChange.toFixed(2)}% in 24h)`,
      `Positive social sentiment (${overallSentiment.toFixed(1)})`,
      `Trading volume supports current move`,
      `${sentimentData.positiveTopics[0] || 'Growing market interest'}`
    ];
    bearishFactors = [
      `Overbought conditions may lead to short-term correction`,
      `${sentimentData.negativeTopics[0] || 'Market volatility risks'}`
    ];
    confidence = 75 + (Math.random() * 10);
  } else if (priceChange < -5 && overallSentiment < -30) {
    // Strong bearish scenario
    conclusion = `${token} is experiencing significant downward pressure with negative price action and sentiment alignment.`;
    recommendation = `Consider reducing exposure to ${token} or implementing hedging strategies.`;
    bullishFactors = [
      `Oversold conditions may present swing opportunities`,
      `${sentimentData.positiveTopics[0] || 'Long-term fundamentals remain intact'}`
    ];
    bearishFactors = [
      `Significant price decline (${priceChange.toFixed(2)}% in 24h)`,
      `Negative social sentiment (${overallSentiment.toFixed(1)})`,
      `${sentimentData.negativeTopics[0] || 'Increasing selling pressure'}`
    ];
    confidence = 70 + (Math.random() * 10);
  } else if (priceChange > 0 && overallSentiment > 0) {
    // Moderate bullish scenario
    conclusion = `${token} shows positive momentum with price appreciation supported by moderately bullish sentiment.`;
    recommendation = `Consider strategic entry points for ${token} with appropriate position sizing.`;
    bullishFactors = [
      `Positive price action (+${priceChange.toFixed(2)}% in 24h)`,
      `Favorable social sentiment (${overallSentiment.toFixed(1)})`,
      `${sentimentData.positiveTopics[0] || 'Growing adoption metrics'}`
    ];
    bearishFactors = [
      `${sentimentData.negativeTopics[0] || 'General market uncertainty'}`,
      `Potential resistance at higher levels`
    ];
    confidence = 65 + (Math.random() * 10);
  } else if (priceChange < 0 && overallSentiment < 0) {
    // Moderate bearish scenario
    conclusion = `${token} is facing headwinds with price depreciation and negative sentiment indicators.`;
    recommendation = `Consider waiting for stabilization signals before adding to ${token} positions.`;
    bullishFactors = [
      `${sentimentData.positiveTopics[0] || 'Long-term value proposition remains'}`,
      `Potential oversold bounce opportunity`
    ];
    bearishFactors = [
      `Negative price action (${priceChange.toFixed(2)}% in 24h)`,
      `Unfavorable social sentiment (${overallSentiment.toFixed(1)})`,
      `${sentimentData.negativeTopics[0] || 'Decreasing buying interest'}`
    ];
    confidence = 60 + (Math.random() * 10);
  } else {
    // Mixed signals scenario
    conclusion = `${token} is showing mixed signals with divergence between price action and sentiment indicators.`;
    recommendation = `Maintain current ${token} positions with tight risk management until clearer direction emerges.`;
    bullishFactors = sentimentData.positiveTopics.length > 0 ? 
      sentimentData.positiveTopics.slice(0, 2) : 
      [`${token} maintains market interest`, `Technical support levels holding`];
    bearishFactors = sentimentData.negativeTopics.length > 0 ? 
      sentimentData.negativeTopics.slice(0, 2) : 
      [`Market uncertainty`, `Unclear directional bias`];
    confidence = 50 + (Math.random() * 15);
  }
  
  return {
    conclusion,
    bullishFactors,
    bearishFactors,
    recommendation,
    confidence
  };
};

/**
 * Fetch AI-generated insights for a specific token
 * @param token The cryptocurrency symbol
 * @param marketData Market data from CoinGecko
 * @param sentimentData Sentiment data from Santiment
 * @returns Promise with AI-generated trading insights
 */
export const fetchAiInsights = async (
  token: string,
  marketData: CoinGeckoMarketData,
  sentimentData: SentimentData
): Promise<string> => {
  try {
    const geminiApiKey = import.meta.env.VITE_GEMINI_API_KEY;
    
    if (!geminiApiKey) {
      throw new Error('Gemini API key not configured. Please add VITE_GEMINI_API_KEY to your environment variables.');
    }
    
    const result = await generateAIInsights(marketData, sentimentData, token);
    return result.conclusion;
  } catch (error) {
    console.error('Error fetching AI insights:', error);
    throw error;
  }
};
